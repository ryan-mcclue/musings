<!-- SPDX-License-Identifier: zlib-acknowledgement -->
hotloading
metaprogramming

discovering for linux docs (xlib, alsa) are code and for 
development may have to add to groups (uinput) 

plugins just be .so files that are loaded with dlsym()

Use of discriminated unions and type fields for type sharing

Visualising essential for debugging insidious problems...
Print rows of text aligned
Conversion from single-state to recording data over time will require memory which we will cast to appropriate state structure, 
e.g. DebugState 
state structures will have `b32 is_initialised` field which will initialise a memory arena
Then have CounterState and CounterSnapshot (move per frame data into this)
Each frame, copy over src to dst (with a rolling buffer)
In the rendering of the records, to display snapshots, generate statistics like min, max, avg.
These will be converged into a Statistic struct for each value
Have helper function for begin, update and end statistic with value
Now we have max, loop over again to generate graph height scale and say red colour scale
Alternatively we could have absolute height scale, e.g `total / 0.033f`
(So in drawing, will typically have 'raw' structures that just have data, and will then
loop over these again to generate relationships to actually draw from etc.)

(TODO: UI have layout and font information...)
Drawing have left_edge, top_edge
Drawing charts, define chart_height, bar_width, bar_spacing etc. in pixels
Can draw single pixel height reference line
Cycle through colours with `arr[index % ARRAY_COUNT(arr)]`

Drawing just take state, and input.
After base drawing, look at input and alter if appropriate

Draw routines with origin vector and vector axis (basis vectors)
Axis that aren't perpendicular causes shearing
