# Rage Against the Machine

  instead of feature, we introduce a patented terminology like user stories to have someone teach you them. slows down development
  business logic .... just means high-order operations in say main()

  Incessent unit-testing, why not test startup assembly then. Falls apart... What not to test, e.g. assume that hex_to_bin() simple enough to work?
  Introducing formulas to determine whether or not to automate something....


certain 'design pattern' enforce really long names to conform to pattern. 
any competent programmer can read use-case specific functions with clearer names
"test_CommandHardware_CheckForMsg_Should_GetCharAndAddToPacker_When_BytesAvailable"

file for every test, file for every class. leads to awful build times

How can software better serve humanity? e.g. bloatware causes slowness for aus post workers

With UML if doing sufficiently complex to the same level as a blueprint, may as well have just written the program
the idea of iterative design would be followed by literal architects, however too costly and time consuming.
with software, we have the ability to do this.
1. design (urban planner): separation of code (mental clarity and division of labour)
design metrics are temporal coupling (physics outputs data to renderer, so format is important), 
layout coupling (renderer inherits from opengl), idealogical coupling (threading, width, memory), fluidity (one change to system causes a major crash)
2. programming (architect)
3. compiler (builder)

Most design patterns are just utility classes rather than a way to architect a program

I don't want to fight the language (Java). Higher level languages should allow you to easily express cpu instructions

reject the idea of TDD driving good design. accept that tests validate design.
tdd and bdd have good elements in them, but the dogma is not effective.

code shouldn't take longer than 10 seconds to compile.

in general we don't add security threats that weren't already present, e.g. loading from shared object could just as easily override binary if have write priveleges to both

even though a 'new' language won't crash, it can still have buffer overruns.
NullPtrExceptions 

c++ struct functions implicitly have a this pointer.
virtual functions will result in a vtable (array of function pointers) to be generated for that struct.
therefore, virtual function will first go to vtable, then lookup in function, so double indirection (so not a zero-cost abstraction)
normal function call just call 0x1234, however with vtable mov rax, qword ptr [rsp + 20] etc. (dereferencing pointers)

an engine makes things that aren't likely to be difficult easy (except for linux...)
important to know low-level to write new tools. we don't have a wheel yet.

for any non-trival task, scripting languages become a hindrance with no static type checking, no real debugger, slow, not as capable.
there are complications in software we have wrongly convinced ourselves are necessary, e.g. scripting for hotloading
hotloading C is far superior, as C is more powerful and can use same debugger (using Lua is a downgrade)
build systems can be useful as they allow for incremental builds (however, in negatively reinforces people to only make small changes)
(speed increase may only be noticeable for large, complex code base)
they are also useful for managing cross compilation (libraries have to be pulled in and compile also)
the idea of incorporating a scripting language into a game was a failed experiment in 2005s.
things like a visual based interface is fine as it is constrained

with closed source it is often the case that a company employs someone to oversee the experience of the software and have q+a 
therefore, better quality with this higher layer of checking than open source.

the best bet in safeguarding security is to reduce the attack surface, which means to reduce the number of lines of code.

Don't restrict right side of bell curve
Let your aces be aces
Being an ace involves having an opinion
Most influential software written largely by one person, e.g Linux, Unix, git etc. Then a team is assigned to maintain it. Fallacy about solo programmer productivity requiring large teams.
Design by committee pushes design to middle of bell curve as opposing views average out

templates add complexity in the debugger (no actual names). 
only really useful if you save a ton of code (not much code to just write each implementation)
if templates are necessary then just use meta-programming as it is much more powerful.

many programs treat memory as an infinite resource. allocating memory is introducing a failure case and making
not a fan of allocation festivals.
we can create our application with minimal failure cases (cannot do this with the platform layer).

uml and diagrams in general are a waste of time (its just code you would write and often fails to capture subtleties)
you should become more proficient at reading code and understanding its relationship.

oh no, we had a security bug in our development version! (printf and friends. printf %f defaults to double)

understanding history is important; c runtime library way of packing return fail information is the reason for inverse truthniess

downloading unverified external tool, always good to get more viruses on my machine...
unless playing at EVO with some maxed out razer device, not feasible to hit that hard
I guess RTFM is the answer to that...

build tools are more of a hindrance! always asking yourself what flags are being passed (linker and compiling separate steps), what files are it picking up, what is the CWD, etc.

Go against merge requests from strangers and just auto let a group of trusted people.
This avoids the problem where you work for hours only to have it blocked

Many online communities are anti-engineering in that they don't embrace criticism. 

Do anything on web takes a lot longer than it should dealing with a myriad of software with different odd conventions. Lack of functionality/integration with hardware will lead to collapse
Many features lacking like type system, try to emulate. Many features have like garbage collection try to avoid.

Scripting languages can cause heap fragmentation. Why just use a real language as we want robustness (scripting languages dependent on interpreter speed) and type checking

Fundamental lack of awareness that there is a better way to program. We all make slow because of lack of time however to say it can't be done is a fallacy.
The cultural differences with these people make it a fool's errand to try and get these people to program correctly
e.g. time visual studio users think is fast is less than 10 seconds?!

Const rarely finds bugs that I have, i.e..writing to a variable a shouldn't. In saying that, you should use features of language that helps you catch bugs. 

Apple store is hardly a free marketplace. They can just block your app for any reason

DRM and engine usage make using games in the future difficult (e.g. museum)

Also, the excessive testing is pushed by web where the poor languages dictate heavy testing. Testing first makes no sense as the app may change

Audiophiles think they hear things that aren't there

Much like the food industry has organic vs processed, we need a term for games that are made by people who love games and care about the experience as opposed to 
large companies concerned with making money (indie vs triple a)

Sometimes crashing is good because it signifies the serious problem that can be rectified immediately rather than some other Insidious hidden bug
The problem is not mapping id/pointer (or whatever std:: c++ people would use) to an entity correctly (i.e. correspondence problem).
the symptom of this problem will be different depending on the implementation, e.g. pointer will crash program.
