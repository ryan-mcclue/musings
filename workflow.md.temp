# Workflow
Git usage

Terminal + Editor + Window manager

Programming Mentality:
DO THE 'MOST CERTAIN' THING FIRST. THIS COULD EITHER BE THE IMPLEMENTATION OR THE USAGE CODE
choose data structures around solving problem

To make anything alternate over time, just multiply by sine(time);

Data hiding hides what the CPU is doing, which is what we care about

Require machine-specific documentation files to understand system we are on

ALMOST ALWAYS CAST TO FLOAT WHEN DOING DIVISIONS LEADING TO FLOAT

Minimum value starts at max

Spreading out randomness: `final_value += contrib * sample`

If debug code (or code that will not be in release) use compile-time macros

Use GLOBAL and global_prefix 
If casting is occuring, always be explicit about it!
Prefixing functions with sdl2_func() or linux_func() 

With error handling, bad practice is to allow a lot of errors, which brings in error classes etc.
Instead, if it's something that is actually an error, e.g. missing file, write the code to explicitly handle it.
Handling the error in a sense makes it no longer an error, rather a feature of the program

Refactoring Mentality:
Refactoring with usage code: just write out structures that satisfy the usage code.
If major rewrite use #if 0 to allow for successful compiling


Debugging Mentality:
When debugging, look through variables and see if anything looks ridiculous


Configuration files should be copied, not generated (becomes too messy)
Symlink to template files from projects

To begin, I ensured that I had a debugger 
from which I could easily step through the application's execution.
In code, I was able to programmatically set system and user breakpoints.

(mocking of syscalls for unit testing with file i/o)

For handling non-fatal errors, single line check. 
For fatal errors, nest all preceding code 
(I have learnt to not be afraid of indentation in this manner).
(error handling in general, i.e. reduce 'errors' by making them part of normal execution flow)

When performing the common task of grouping data, a few practices to keep in mind.
Use fixed sized types to always know about struct padding 
(in fact, I like to extend this to all my code)

If wanting multiple ways of accessing grouped data, use union and anonymous structs.
Use an int to reference other structs, e.g. `plane_index` 

If the data being grouped can only exist together (e.g. points), use vectors.
Put all structs related typedefs inside their own header file for easy access.

As floats are an approximation, when comparing to 0.0f (say for a denominator check) 
or negative (say for a square root) use a tolerance/epsilon less-than/greater-than check.
In fact whenever dividing should always ask oneself "can the value be zero?"
To be clear about float to int casting, use a macro like truncate/round (think about what if uneven divide)
Due to mixed integer and float arithmetic going to float, calculate integer percentages `val * 100 / total`
There is no need to overload the division operator as can do `(* 1.0f / val)`

For easy substitution, use single letter prefix names like `output_h` and `output_w`.
Convention for variable arrays, e.g. `Planes plane[1]`, `planes` and `plane_count (use ARRAY_COUNT macro here)` 
Put for loop statements on separate line to help not be afraid of indentation.
Iterate over pixel space and then convert to say, world space for calculations (normalisation and lerp)
Aspect ratio correction is simply rearranging a ratio. 
If we determine one side is larger, scale other.
Use "\r" ASCII code to print a status indicator.
Only use const for char * string literals stored in the data segment.

Endianness comes into play when reading/writing from disk (e.g. file type magic value) and working directly with `u8 *` (e.g. iterating through bytes of a u32) 
